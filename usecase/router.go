package usecase

import (
	"bytes"
	"fmt"
	"github.com/iancoleman/strcase"
	"go/format"
	"mk-oapigen-go/entity"
	"net/http"
)

type RouterGenerator struct {
	Package       string
	SchemaPackage string
}

func (g RouterGenerator) CreateConstructor(route entity.Route) (str string) {
	str = fmt.Sprintf(
		""+
			"func New%sServiceRouter(p %s%sServiceProvider) (%sServiceRouter, error) { \n"+
			" s,err := p() \n"+
			" return %sServiceRouter{service : s}, err \n"+
			"} \n",
		route.Name,
		g.SchemaPackage,
		route.Name,
		route.Name,
		route.Name,
	)
	return
}

func (g RouterGenerator) CreateHeader() (str string) {
	return fmt.Sprintf("// Package %s \n"+
		"//this file is generated by swag2go. DO NOT EDIT\n"+
		"//    authorized : miyagawa.ryohei\n"+
		"package %s\n"+
		"\n"+
		"import ( \n"+
		"\"encoding/json\"\n"+
		"\n"+
		"\"github.com/gin-gonic/gin\"\n"+
		")\n",
		g.Package,
		g.Package,
	)
	return
}

func (g RouterGenerator) CreateStruct(route entity.Route) (str string) {
	str = fmt.Sprintf(""+
		"type %sServiceRouter struct { service %s%sService } \n",
		route.Name,
		g.SchemaPackage,
		route.Name,
	)
	return
}

func (g RouterGenerator) CreateHandleFunc(method entity.Method) (str string) {
	respSet := ""
	if method.Response.StructRef != nil || method.Response.ArrayRef != nil {
		respSet = "ctx.JSON(200,*resp)"
	} else {
		respSet = "ctx.String(200,string(*resp))"
	}
	req := ""
	if method.Type == http.MethodGet {
		if method.Request.StructRef != nil {
			if method.Request.StructRef.PropertyList == nil {
				req = fmt.Sprintf(
					"var req %s%s\n",
					g.SchemaPackage,
					method.Request.StructRef.Name,
				)
			} else {
				structStr := ""
				req = req + "var err error = nil \n"

				for _, p := range method.Request.StructRef.PropertyList {
					name := strcase.ToLowerCamel(p.Name)
					getMethod := "Param"
					if p.Tag.Type == "query" {
						getMethod = "Query"
					}
					switch p.Type {
					case "int":
						req = req + fmt.Sprintf(
							"%sBuf := ctx.%s(\"%s\")\n"+
								"%s,err := strconv.AtoI(%sBuf)\n",
							name,
							getMethod,
							p.Tag.Name,
							name,
							name,
						)
						break
					case "int64":
						req = req + fmt.Sprintf(
							"%sBuf := ctx.%s(\"%s\")\n"+
								"%sInt,err := strconv.Atoi(%sBuf)\n"+
								"%s := int64(%sInt)\n",
							name,
							getMethod,
							p.Tag.Name,
							name,
							name,
							name,
							name,
						)
						break
					case "int32":
						req = req + fmt.Sprintf(
							"%sBuf := ctx.%s(\"%s\")\n"+
								"%sInt,err := strconv.Atoi(%sBuf)\n"+
								"%s := int64(%sInt)\n",
							name,
							getMethod,
							p.Tag.Name,
							name,
							name,
							name,
							name,
						)
						break
					case "float":
						req = req + fmt.Sprintf(
							"%sBuf := ctx.%s(\"%s\")\n"+
								"%s,err := strconv.ParseFloat(%sBuf,64)\n",
							name,
							getMethod,
							p.Tag.Name,
							name,
							name,
						)
						break
					case "float64":
						req = req + fmt.Sprintf(
							"%sBuf := ctx.%s(\"%s\")\n"+
								"%s,err := strconv.ParseFloat(%sBuf,64)\n",
							name,
							getMethod,
							p.Tag.Name,
							name,
							name,
						)
						break
					case "float32":
						req = req + fmt.Sprintf(
							"%sBuf := ctx.%s(\"%s\")\n"+
								"%s,err := strconv.ParseFloat(%sBuf,64)\n",
							name,
							getMethod,
							p.Tag.Name,
							name,
							name,
						)
						break
					case "bool":
						req = req + fmt.Sprintf(
							"%sBuf := ctx.%s(\"%s\")\n"+
								"%s,err := strconv.ParseBool(%sBuf,64)\n",
							name,
							getMethod,
							p.Tag.Name,
							name,
							name,
						)
						break
					case "time.Time":
						req = req + fmt.Sprintf(
							"%sBuf := ctx.%s(\"%s\")\n"+
								"%s,err := time.Parse(time.RFC3339, %sBuf)\n",
							name,
							getMethod,
							p.Tag.Name,
							name,
							name,
						)
						break
					case "string":
						req = req + fmt.Sprintf(
							"%s := ctx.%s(\"%s\")\n",
							name,
							getMethod,
							p.Tag.Name,
						)
					default:
						req = req + fmt.Sprintf(
							"var %s %s%s \n"+
								"%sBuf := bytes.NewBufferString(ctx.%s(\"%s\")).Bytes()\n"+
								"err = json.Unmarshal(%sBuf,&%s)\n",
							name,
							g.SchemaPackage,
							p.Type,
							name,
							getMethod,
							p.Tag.Name,
							name,
							name,
						)
						break
					}
					req = req + fmt.Sprintf(""+
						"if err != nil {\n"+
						"    ctx.Error(err)\n"+
						"    return \n"+
						"}\n",
					)
					structStr = structStr + fmt.Sprintf(
						"%s : %s,\n",
						p.Name,
						name,
					)
				}
				req = req + fmt.Sprintf(""+
					"req := &%s%s{\n"+
					"%s"+
					"} \n",
					g.SchemaPackage,
					method.Request.Name,
					structStr,
				)
			}
		}
	} else {
		if method.Request.StructRef != nil || method.Request.ArrayRef != nil {
			req = fmt.Sprintf(""+
				"req := new(%s%s) \n"+
				"if err := ctx.BindJSON(req); err != nil {\n"+
				"ctx.Error(err)\n"+
				"return \n"+
				"}\n",
				g.SchemaPackage,
				method.Request.Name,
			)
		}
	}
	request := "*req"
	if req == "" {
		request = ""
	}
	str = fmt.Sprintf(""+
		"func(ctx *gin.Context) { \n"+
		"%s\n"+
		"resp, err := r.service.%s(%s)\n"+
		"if err != nil {\n"+
		"ctx.Error(err)\n"+
		"return \n"+
		"}\n"+
		"%s\n"+
		"} \n",
		req,
		method.Name,
		request,
		respSet,
	)
	return
}

func (g RouterGenerator) CreateRouteRepositoryFunc(route entity.Route) (str string) {
	for _, method := range route.Methods {
		rogic := g.CreateHandleFunc(method)
		str = fmt.Sprintf("%s\n"+
			"func (r %sServiceRouter)  Get%sHandler() gin.HandlerFunc { \n"+
			"return %s \n"+
			"}\n",
			str,
			route.Name,
			method.Type,
			rogic,
		)

	}
	return
}

func (g RouterGenerator) CreateRouter(routes []entity.Route) (str string) {
	str = g.CreateHeader()
	for _, route := range routes {
		str = str + g.CreateStruct(route)
		str = str + g.CreateRouteRepositoryFunc(route)
		str = str + g.CreateConstructor(route)
	}
	return
}

func (g RouterGenerator) PrintRouter(routes []entity.Route) {
	str := g.CreateRouter(routes)
	written, err := format.Source(bytes.NewBufferString(str).Bytes())
	if err != nil {
		panic(err)
	}
	fmt.Println(string(written))
	return

}

func NewRouterGenerator(p string, s string) RouterGenerator {
	if s != "" {
		s = s + "."
	}
	return RouterGenerator{
		Package:       p,
		SchemaPackage: s,
	}
}
