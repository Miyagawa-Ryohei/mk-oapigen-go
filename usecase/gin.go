package usecase

import (
	"bytes"
	"fmt"
	"github.com/iancoleman/strcase"
	"go/format"
	"mk-oapigen-go/entity"
	"strings"
)

type ServerGenerator struct {
	Package       string
	RouterPackage string
}

func (g ServerGenerator) CreateGinStruct() (str string) {
	return fmt.Sprintf("// Package %s \n"+
		"//this file is generated by swag2go. DO NOT EDIT\n"+
		"//    authorized : miyagawa.ryohei\n"+
		"package %s\n"+
		"\n"+
		"import ( \n"+
		"\"github.com/gin-gonic/gin\"\n"+
		")\n"+
		"\n type Server struct {\n"+
		"engine *gin.Engine\n"+
		"}\n",
		g.Package,
		g.Package,
	)
	return
}

func (g ServerGenerator) CreateRouterRegister(routes []entity.Route) (str string) {
	args := ""
	funcConts := ""
	groupMap := map[string][]entity.Route{}
	for _, r := range routes {
		if _, ok := groupMap[r.Group]; !ok {
			groupMap[r.Group] = []entity.Route{}
		}
		groupMap[r.Group] = append(groupMap[r.Group], r)
	}

	for group, routes := range groupMap {
		instanceStr := "s.engine."
		funcConts = funcConts + "\n"
		if group != "/" {
			g := strings.Replace(group, "/", "", -1)
			funcConts = funcConts + fmt.Sprintf("%s := s.engine.Group(\"%s\")\n", g, group)
			instanceStr = g + "."
		}
		for _, r := range routes {
			argName := strcase.ToLowerCamel(r.Name)
			args = args + fmt.Sprintf(
				"%s %s%sServiceRouter,\n",
				argName,
				g.RouterPackage,
				r.Name,
			)
			for _, m := range r.Methods {
				method := strcase.ToCamel(m.Type)
				funcConts = funcConts + fmt.Sprintf(
					"%s%s(\"%s\",%s.Get%sHandler())\n",
					instanceStr,
					method,
					r.Path,
					argName,
					m.Type,
				)
			}
		}
	}
	str = fmt.Sprintf(""+
		"func (s *Server) RegistRouter (\n"+
		" %s "+
		"middleWares... gin.HandlerFunc,\n"+
		") { \n"+
		"if len(middleWares) > 0 {\n"+
		"    s.engine.Use(middleWares...)\n"+
		"}\n"+
		" %s}\n\n",
		args,
		funcConts,
	)

	return
}

func (g ServerGenerator) CreateListen(server entity.Server) (str string) {
	str = fmt.Sprintf(
		"func(s *Server) Listen(port *string) error { \n"+
			"p := \"%s\"\n"+
			"if port != nil { \n"+
			"    p = *port\n"+
			"}\n"+
			"return s.engine.Run(\":\" + p)\n"+
			"}\n\n",
		server.Port)
	return
}

func (g ServerGenerator) CreateExporterRouteRegister(server entity.Server) string {
	if !server.Prometheus {
		return ""
	}
	return "" +
		"func (s *Server) RegistExporter(exporter gin.HandlerFunc) { \n" +
		"    s.engine.GET(\"/metrics\", exporter)\n" +
		"}\n\n"

}

func (g ServerGenerator) CreateServer(server entity.Server, routes []entity.Route) (str string) {
	str = str + g.CreateGinStruct()
	str = str + g.CreateExporterRouteRegister(server)
	str = str + g.CreateRouterRegister(routes)
	str = str + g.CreateListen(server)
	str = str + g.CreateConstructor()
	return
}

func (g ServerGenerator) CreateConstructor() (str string) {
	return fmt.Sprintf("" +
		"func NewServer() *Server {\n" +
		"    return &Server{\n" +
		"        engine : gin.New(),\n" +
		"    }\n" +
		"}\n")
}

func (g ServerGenerator) PrintServer(server entity.Server, routers []entity.Route) (str string) {
	str = g.CreateServer(server, routers)

	written, err := format.Source(bytes.NewBufferString(str).Bytes())
	if err != nil {
		panic(err)
	}
	fmt.Println(string(written))
	return
}

func NewServerGenerator(packageName string, routerPackage string) ServerGenerator {
	if routerPackage != "" {
		routerPackage = routerPackage + "."
	}
	return ServerGenerator{
		Package:       packageName,
		RouterPackage: routerPackage,
	}
}
