package usecase

import (
	"bytes"
	_ "embed"
	"fmt"
	"go/format"
	"mk-oapigen-go/entity"
	"strings"
)

var defined map[string]bool

type TypeGenerator struct {
	Package string
}

func (g TypeGenerator) CreateHTTPError() string {
	return fmt.Sprintf("" +
		"var ( \n" +
		"    BadRequest          = errors.New(\"BadRequest\")\n" +
		"    Unauthorized        = errors.New(\"Unauthorized\")\n" +
		"    NotFound            = errors.New(\"NotFound\")\n" +
		"    NotImplemented      = errors.New(\"NotImplemented\")\n" +
		"    BadGateway          = errors.New(\"BadGateway\")\n" +
		"    InternalServerError = errors.New(\"InternalServerError\")\n" +
		")\n",
	)
}

func (g TypeGenerator) CreateHeader() string {
	return fmt.Sprintf("// Package %s \n"+
		"//this file is generated by swag2go. DO NOT EDIT\n"+
		"//    authorized : miyagawa.ryohei\n"+
		"package %s\n"+
		"\n"+
		"import ( \n"+
		"\"github.com/pkg/errors\"\n"+
		")\n",
		g.Package,
		g.Package,
	)
}

func (g TypeGenerator) ExtractTypes(routes []entity.Route) []entity.Schema {
	ret := []entity.Schema{}
	for _, r := range routes {
		for _, m := range r.Methods {
			if m.Request.Name != "" {
				ret = append(ret, m.Request)
			}
			if m.Response.Name != "" {
				ret = append(ret, m.Response)
			}
		}
	}
	return ret
}

func (g TypeGenerator) CreateStruct(schema *entity.StructSchema) (str string) {
	str = ""
	createProperty := func(pl []entity.PropertySchema) string {
		ret := ""
		for _, p := range pl {
			ret = ret + fmt.Sprintf(
				" %s %s",
				p.Name,
				p.Type,
			)
			if p.Tag != nil {
				ret = fmt.Sprintf(
					"%s `%s:\"%s\"`",
					ret,
					p.Tag.Type,
					strings.Join(p.Tag.Options, ","),
				)
			}
			ret = ret + "\n\n"
		}
		return ret
	}

	if _, ok := defined[schema.Name]; !ok {
		str = str + fmt.Sprintf("type %s struct { \n %s \n}\n\n",
			schema.Name,
			createProperty(schema.PropertyList),
		)
	}

	for _, p := range schema.PropertyList {
		if p.StructRef != nil {
			str = str + g.CreateStruct(p.StructRef)
		} else if p.ArrayRef != nil {
			str = str + g.CreateArray(p.ArrayRef)
		}
	}
	defined[schema.Name] = true
	return
}

func (g TypeGenerator) CreateArray(schema *entity.ArraySchema) (str string) {
	str = ""
	if _, ok := defined[schema.Name]; !ok {
		str = str + fmt.Sprintf("type %s []%s \n\n",
			schema.Name,
			schema.ItemType,
		)
	}
	if schema.StructRef != nil {
		str = str + g.CreateStruct(schema.StructRef)
	} else if schema.ArrayRef != nil {
		str = str + g.CreateArray(schema.ArrayRef)
	}
	defined[schema.Name] = true
	return
}

func CreatePremitive(schema entity.Property) (str string) {
	if _, ok := defined[schema.GetName()]; !ok {
		str = str + fmt.Sprintf("type %s %s\n\n", schema.GetName(), schema.GetType())
	}
	defined[schema.GetName()] = true
	return
}

func (g TypeGenerator) CreateType(list []entity.Schema) (str string) {
	str = ""
	str = str + g.CreateHTTPError()
	for _, l := range list {
		if l.StructRef != nil {
			str = str + g.CreateStruct(l.StructRef)
		} else if l.ArrayRef != nil {
			str = str + g.CreateArray(l.ArrayRef)
		} else {
			str = str + CreatePremitive(l)
		}
	}
	return
}

func (g TypeGenerator) PrintType(list []entity.Schema) {
	defined = make(map[string]bool)

	buf := bytes.NewBufferString(fmt.Sprintf(
		"%s\n"+
			"%s\n",
		g.CreateHeader(),
		g.CreateType(list),
	))
	written, err := format.Source(buf.Bytes())
	if err != nil {
		panic(err)
	}
	fmt.Println(string(written))
}

func NewTypeGenerator(p string) TypeGenerator {
	return TypeGenerator{
		Package: p,
	}
}
